name: Sirius CI/CD Pipeline

# Canonical CI pipeline. Handles all builds, tests, and canary dispatch.
# deploy.yml is now deployment-only (workflow_dispatch) and does not build images.
#
# Multi-arch strategy: each container is built separately on native amd64 and
# arm64 runners (via Blacksmith) to avoid slow QEMU cross-compilation.
# After both arch builds succeed, arch-specific tags are merged into a single
# multi-arch manifest.

on:
  push:
    branches: [main, sirius-demo]
  pull_request:
    branches: [main]
  repository_dispatch:
    types: [submodule-update]

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: siriusscan

jobs:
  # ─────────────────────────────────────────────────────────────────────────────
  # Detect which services actually changed so we only build what's needed
  # ─────────────────────────────────────────────────────────────────────────────
  detect-changes:
    name: Detect Changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      sirius_ui_changes: ${{ steps.changes.outputs.sirius_ui_changes }}
      sirius_api_changes: ${{ steps.changes.outputs.sirius_api_changes }}
      sirius_engine_changes: ${{ steps.changes.outputs.sirius_engine_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Changed Files
        id: changes
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            echo "submodule_changes=true" >> $GITHUB_OUTPUT
            echo "Submodule update detected: $SUBMODULE"

            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')

            case $REPO_NAME in
              "go-api")
                echo "Affects both sirius-api and sirius-engine"
                echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
              "app-scanner"|"app-terminal"|"sirius-nse"|"app-agent")
                echo "Affects sirius-engine"
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "Unknown submodule, rebuilding everything"
                echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
            esac
          else
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              BASE_SHA=${{ github.event.pull_request.base.sha }}
              HEAD_SHA=${{ github.event.pull_request.head.sha }}
            else
              BASE_SHA=${{ github.event.before }}
              HEAD_SHA=${{ github.event.after }}
            fi

            git diff --name-only $BASE_SHA $HEAD_SHA > changed_files.txt

            if grep -q "sirius-ui/" changed_files.txt; then
              echo "UI changes detected"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
            fi

            if grep -q "sirius-api/" changed_files.txt; then
              echo "API changes detected"
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
            fi

            if grep -q "sirius-engine/" changed_files.txt || grep -q "rabbitmq/" changed_files.txt; then
              echo "Engine or RabbitMQ changes detected"
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi

            # Dockerfile or CI changes trigger a full rebuild
            if grep -q -E "(Dockerfile|\.github/|docker-compose)" changed_files.txt; then
              echo "Docker or CI changes detected, rebuilding everything"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi

            # No specific changes but something did change: full rebuild
            if [ ! -s changed_files.txt ]; then
              echo "General changes detected, rebuilding everything"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  # ─────────────────────────────────────────────────────────────────────────────
  # Verify base images exist in GHCR before any application build starts.
  # This catches the race condition where Build Base Images and CI both trigger
  # on the same push (e.g. when base-images/ and Dockerfile change together),
  # giving a clear error message instead of a cryptic buildkit stack trace.
  # ─────────────────────────────────────────────────────────────────────────────
  verify-base-images:
    name: "Verify Base Images"
    needs: detect-changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Verify base images exist
        run: |
          set -e
          echo "Checking ghcr.io/siriusscan/sirius-base-go-builder:latest ..."
          docker manifest inspect ghcr.io/siriusscan/sirius-base-go-builder:latest > /dev/null || {
            echo "::error::Base image sirius-base-go-builder:latest not found in GHCR."
            echo "::error::Run the 'Build Base Images' workflow first (Actions → Build Base Images → Run workflow)."
            exit 1
          }
          echo "Checking ghcr.io/siriusscan/sirius-base-engine-tools:latest ..."
          docker manifest inspect ghcr.io/siriusscan/sirius-base-engine-tools:latest > /dev/null || {
            echo "::error::Base image sirius-base-engine-tools:latest not found in GHCR."
            echo "::error::Run the 'Build Base Images' workflow first (Actions → Build Base Images → Run workflow)."
            exit 1
          }
          echo "All base images verified."

  # ─────────────────────────────────────────────────────────────────────────────
  # Build sirius-ui
  # Native runners per architecture avoid QEMU emulation of npm/Next.js builds.
  # PRs build amd64 only; main/dispatch builds both arches.
  # ─────────────────────────────────────────────────────────────────────────────
  build-ui:
    name: "Build UI (${{ matrix.platform }})"
    needs: [detect-changes, verify-base-images]
    if: needs.detect-changes.outputs.sirius_ui_changes == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ github.event_name == 'pull_request' && fromJSON('["amd64"]') || fromJSON('["amd64","arm64"]') }}
        include:
          - platform: amd64
            runner: blacksmith-4vcpu-ubuntu-2404
          - platform: arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm

    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      - name: Install UI dependencies
        run: npm ci
        working-directory: sirius-ui

      - name: Lint UI code
        continue-on-error: true
        run: npm run lint
        working-directory: sirius-ui

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-ui (${{ matrix.platform }})
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-ui
          platforms: linux/${{ matrix.platform }}
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-ui:${{ steps.meta.outputs.image_tag }}-${{ matrix.platform }}

  # Merge arch-specific UI images into a single multi-arch manifest
  merge-ui:
    name: "Merge UI Manifest"
    needs: build-ui
    if: needs.detect-changes.outputs.sirius_ui_changes == 'true' && github.event_name != 'pull_request'
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Generate image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            echo "image_tag=dev" >> $GITHUB_OUTPUT
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Create and push multi-arch manifest for sirius-ui
        run: |
          TAG="${{ steps.meta.outputs.image_tag }}"
          BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-ui"

          # buildx imagetools handles Blacksmith manifest lists (provenance-enabled);
          # docker manifest create cannot nest manifest lists.
          docker buildx imagetools create -t ${BASE}:${TAG} \
            ${BASE}:${TAG}-amd64 \
            ${BASE}:${TAG}-arm64

          if [ "${{ steps.meta.outputs.also_tag_beta }}" == "true" ]; then
            docker buildx imagetools create -t ${BASE}:beta \
              ${BASE}:${TAG}-amd64 \
              ${BASE}:${TAG}-arm64
          fi

          echo "Published ${BASE}:${TAG} (amd64 + arm64)"

  # ─────────────────────────────────────────────────────────────────────────────
  # Build sirius-api
  # ─────────────────────────────────────────────────────────────────────────────
  build-api:
    name: "Build API (${{ matrix.platform }})"
    needs: [detect-changes, verify-base-images]
    if: needs.detect-changes.outputs.sirius_api_changes == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ github.event_name == 'pull_request' && fromJSON('["amd64"]') || fromJSON('["amd64","arm64"]') }}
        include:
          - platform: amd64
            runner: blacksmith-4vcpu-ubuntu-2404
          - platform: arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm

    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')
            COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
            if [ "$REPO_NAME" == "go-api" ]; then
              echo "GO_API_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
            fi
          fi

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Compile-check API code
        run: |
          go mod download
          go vet ./...
        working-directory: sirius-api

      - name: Run API tests (non-blocking)
        continue-on-error: true
        run: go test ./... -short -count=1
        working-directory: sirius-api

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-api (${{ matrix.platform }})
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-api
          platforms: linux/${{ matrix.platform }}
          push: true
          build-args: |
            GO_API_COMMIT_SHA=${{ env.GO_API_COMMIT_SHA || 'v0.0.15' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-api:${{ steps.meta.outputs.image_tag }}-${{ matrix.platform }}

  # Merge arch-specific API images into a single multi-arch manifest
  merge-api:
    name: "Merge API Manifest"
    needs: build-api
    if: needs.detect-changes.outputs.sirius_api_changes == 'true' && github.event_name != 'pull_request'
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Generate image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            echo "image_tag=dev" >> $GITHUB_OUTPUT
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Create and push multi-arch manifest for sirius-api
        run: |
          TAG="${{ steps.meta.outputs.image_tag }}"
          BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-api"

          docker buildx imagetools create -t ${BASE}:${TAG} \
            ${BASE}:${TAG}-amd64 \
            ${BASE}:${TAG}-arm64

          if [ "${{ steps.meta.outputs.also_tag_beta }}" == "true" ]; then
            docker buildx imagetools create -t ${BASE}:beta \
              ${BASE}:${TAG}-amd64 \
              ${BASE}:${TAG}-arm64
          fi

          echo "Published ${BASE}:${TAG} (amd64 + arm64)"

  # ─────────────────────────────────────────────────────────────────────────────
  # Build sirius-engine
  # ─────────────────────────────────────────────────────────────────────────────
  build-engine:
    name: "Build Engine (${{ matrix.platform }})"
    needs: [detect-changes, verify-base-images]
    if: needs.detect-changes.outputs.sirius_engine_changes == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ github.event_name == 'pull_request' && fromJSON('["amd64"]') || fromJSON('["amd64","arm64"]') }}
        include:
          - platform: amd64
            runner: blacksmith-4vcpu-ubuntu-2404
          - platform: arm64
            runner: blacksmith-4vcpu-ubuntu-2404-arm

    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate image tag and submodule SHAs
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')
            COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
            REPO_NAME_UPPER=$(echo $REPO_NAME | tr '-' '_' | tr 'a-z' 'A-Z')
            echo "${REPO_NAME_UPPER}_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
          fi

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Compile-check Engine code
        run: |
          go mod download
          go vet ./...
        working-directory: sirius-engine

      - name: Run Engine tests (non-blocking)
        continue-on-error: true
        run: go test ./... -short -count=1
        working-directory: sirius-engine

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-engine (${{ matrix.platform }})
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-engine
          platforms: linux/${{ matrix.platform }}
          push: true
          build-args: |
            GO_API_COMMIT_SHA=${{ env.GO_API_COMMIT_SHA || 'v0.0.14' }}
            APP_SCANNER_COMMIT_SHA=${{ env.APP_SCANNER_COMMIT_SHA || '4a47f73' }}
            APP_TERMINAL_COMMIT_SHA=${{ env.APP_TERMINAL_COMMIT_SHA || 'main' }}
            SIRIUS_NSE_COMMIT_SHA=${{ env.SIRIUS_NSE_COMMIT_SHA || 'main' }}
            APP_AGENT_COMMIT_SHA=${{ env.APP_AGENT_COMMIT_SHA || '50b405a' }}
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-engine:${{ steps.meta.outputs.image_tag }}-${{ matrix.platform }}

  # Merge arch-specific Engine images into a single multi-arch manifest
  merge-engine:
    name: "Merge Engine Manifest"
    needs: build-engine
    if: needs.detect-changes.outputs.sirius_engine_changes == 'true' && github.event_name != 'pull_request'
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Generate image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            echo "image_tag=dev" >> $GITHUB_OUTPUT
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Create and push multi-arch manifest for sirius-engine
        run: |
          TAG="${{ steps.meta.outputs.image_tag }}"
          BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-engine"

          docker buildx imagetools create -t ${BASE}:${TAG} \
            ${BASE}:${TAG}-amd64 \
            ${BASE}:${TAG}-arm64

          if [ "${{ steps.meta.outputs.also_tag_beta }}" == "true" ]; then
            docker buildx imagetools create -t ${BASE}:beta \
              ${BASE}:${TAG}-amd64 \
              ${BASE}:${TAG}-arm64
          fi

          echo "Published ${BASE}:${TAG} (amd64 + arm64)"

  # ─────────────────────────────────────────────────────────────────────────────
  # Integration Test
  #
  # Runs after at least one service build (or merge for multi-arch) succeeds.
  # Key fixes vs the previous version:
  #   1. sirius-api is ALWAYS started when sirius-engine is tested, because
  #      start-enhanced.sh validates the API key contract at startup.
  #   2. sirius-engine depends_on sirius-api in the test compose config.
  #   3. The health-wait loop covers sirius-api even when only engine changed.
  # ─────────────────────────────────────────────────────────────────────────────
  test:
    name: Integration Test
    needs:
      - detect-changes
      - build-ui
      - build-api
      - build-engine
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: >
      always() &&
      (
        needs.build-ui.result == 'success' ||
        needs.build-api.result == 'success' ||
        needs.build-engine.result == 'success'
      )
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Determine image tag
        id: tag
        run: |
          # Compute the tag the same way build jobs do (from event context).
          # build-* are matrix jobs with no job-level outputs, so we cannot
          # use needs.build-ui.outputs.image_tag — it is always empty.
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/sirius-demo" ]; then
            TAG="dev"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
          else
            TAG="latest"
          fi
          # Integration tests always use the amd64 arch-specific image tag
          echo "image_tag=${TAG}-amd64" >> $GITHUB_OUTPUT
          echo "Using image tag: ${TAG}-amd64"

      - name: Create test environment
        run: |
          cat > docker-compose.test.yml << 'EOF'
          name: sirius-test
          services:
            sirius-postgres:
              image: postgres:15-alpine
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: postgres
                POSTGRES_DB: sirius_test
              tmpfs:
                - /var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-rabbitmq:
              image: rabbitmq:3-management
              environment:
                RABBITMQ_DEFAULT_USER: guest
                RABBITMQ_DEFAULT_PASS: guest
              healthcheck:
                test: ["CMD", "rabbitmq-diagnostics", "ping"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-valkey:
              image: valkey/valkey:latest
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-ui:
              image: ${SIRIUS_UI_IMAGE}
              environment:
                - NODE_ENV=production
                - SKIP_ENV_VALIDATION=1
                - DATABASE_URL=postgresql://postgres:postgres@sirius-postgres:5432/sirius_test
                - NEXTAUTH_SECRET=test-secret
                - INITIAL_ADMIN_PASSWORD=test-admin-password
                - NEXTAUTH_URL=http://localhost:3000
                - SIRIUS_API_URL=http://sirius-api:9001
                - NEXT_PUBLIC_SIRIUS_API_URL=http://localhost:9001
                - SIRIUS_API_KEY=ci-placeholder-api-key
              depends_on:
                sirius-postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD-SHELL", "wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 15s

            sirius-api:
              image: ${SIRIUS_API_IMAGE}
              environment:
                - GO_ENV=production
                - API_PORT=9001
                - POSTGRES_HOST=sirius-postgres
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres
                - POSTGRES_DB=sirius_test
                - POSTGRES_PORT=5432
                - VALKEY_HOST=sirius-valkey
                - VALKEY_PORT=6379
                - RABBITMQ_URL=amqp://guest:guest@sirius-rabbitmq:5672/
                - LOG_LEVEL=info
                - SIRIUS_API_KEY=ci-placeholder-api-key
              depends_on:
                sirius-postgres:
                  condition: service_healthy
                sirius-rabbitmq:
                  condition: service_healthy
                sirius-valkey:
                  condition: service_healthy
              healthcheck:
                test: ["CMD-SHELL", "STATUS=$(curl -s -o /dev/null -w '%{http_code}' -H 'X-API-Key: ci-placeholder-api-key' http://127.0.0.1:9001/host/); echo \"API health probe: $$STATUS\"; [ -n \"$$STATUS\" ] && [ \"$$STATUS\" != '000' ] && echo \"$$STATUS\" | grep -qvE '^5'"]
                interval: 10s
                timeout: 10s
                retries: 24
                start_period: 30s

            sirius-engine:
              image: ${SIRIUS_ENGINE_IMAGE}
              environment:
                - GO_ENV=production
                - ENGINE_MAIN_PORT=5174
                - GRPC_AGENT_PORT=50051
                - POSTGRES_HOST=sirius-postgres
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres
                - POSTGRES_DB=sirius_test
                - POSTGRES_PORT=5432
                - VALKEY_HOST=sirius-valkey
                - VALKEY_PORT=6379
                - RABBITMQ_URL=amqp://guest:guest@sirius-rabbitmq:5672/
                - LOG_LEVEL=info
                - SIRIUS_API_KEY=ci-placeholder-api-key
                - SIRIUS_API_URL=http://sirius-api:9001
              depends_on:
                sirius-postgres:
                  condition: service_healthy
                sirius-rabbitmq:
                  condition: service_healthy
                sirius-valkey:
                  condition: service_healthy
                sirius-api:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "bash", "-c", "echo > /dev/tcp/127.0.0.1/50051"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 30s
          EOF

          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"
          export SIRIUS_UI_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-ui:${IMAGE_TAG}"
          export SIRIUS_API_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-api:${IMAGE_TAG}"
          export SIRIUS_ENGINE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-engine:${IMAGE_TAG}"
          echo "SIRIUS_UI_IMAGE=$SIRIUS_UI_IMAGE" >> $GITHUB_ENV
          echo "SIRIUS_API_IMAGE=$SIRIUS_API_IMAGE" >> $GITHUB_ENV
          echo "SIRIUS_ENGINE_IMAGE=$SIRIUS_ENGINE_IMAGE" >> $GITHUB_ENV

      - name: Run integration test
        run: |
          echo "Starting integration test..."

          # 1. Infrastructure services
          docker compose -f docker-compose.test.yml up -d sirius-postgres sirius-rabbitmq sirius-valkey

          echo "Waiting for infrastructure services to become healthy..."
          timeout 90 bash -c '
            until docker compose -f docker-compose.test.yml ps --format json | \
              python3 -c "
          import sys, json
          svcs = [json.loads(l) for l in sys.stdin if l.strip()]
          infra = [s for s in svcs if s[\"Service\"] in (\"sirius-postgres\",\"sirius-rabbitmq\",\"sirius-valkey\")]
          healthy = [s for s in infra if s.get(\"Health\",\"\") == \"healthy\"]
          sys.exit(0 if len(healthy) == 3 else 1)
          "; do sleep 3; done
          '
          echo "Infrastructure healthy"

          # 2. Determine which application services to test.
          #    IMPORTANT: sirius-api must always be started alongside sirius-engine
          #    because start-enhanced.sh validates the API key contract at startup.
          SERVICES_TO_TEST=""
          API_REQUIRED=false

          if [ "${{ needs.detect-changes.outputs.sirius_api_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-api"
            API_REQUIRED=true
          fi

          if [ "${{ needs.detect-changes.outputs.sirius_engine_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-engine"
            # Engine requires the API to be running for its startup preflight check
            if [ "$API_REQUIRED" != "true" ]; then
              SERVICES_TO_TEST="sirius-api$SERVICES_TO_TEST"
              API_REQUIRED=true
              echo "Adding sirius-api as required dependency for sirius-engine"
            fi
          fi

          if [ "${{ needs.detect-changes.outputs.sirius_ui_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-ui"
          fi

          if [ -z "$SERVICES_TO_TEST" ]; then
            echo "No application services to test"
            exit 0
          fi

          echo "Starting application services:$SERVICES_TO_TEST"
          docker compose -f docker-compose.test.yml up -d $SERVICES_TO_TEST

          # 3. Wait for each service to become healthy
          for SVC in $SERVICES_TO_TEST; do
            case $SVC in
              sirius-api)    HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:9001/health" ;;
              sirius-engine) HEALTH_CMD="bash -c 'echo > /dev/tcp/127.0.0.1/50051'" ;;
              sirius-ui)     HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/" ;;
              *) continue ;;
            esac
            echo "Waiting for $SVC..."
            timeout 180 bash -c "
              until docker compose -f docker-compose.test.yml exec -T $SVC sh -c '$HEALTH_CMD' 2>/dev/null; do
                sleep 5
              done
            "
            echo "$SVC is healthy"
          done

          # 4. Final health assertions
          echo "Service status:"
          docker compose -f docker-compose.test.yml ps

          echo "Running final health assertions..."
          FAILED=0
          for SVC in $SERVICES_TO_TEST; do
            case $SVC in
              sirius-api)    HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:9001/health" ;;
              sirius-engine) HEALTH_CMD="bash -c 'echo > /dev/tcp/127.0.0.1/50051'" ;;
              sirius-ui)     HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/" ;;
              *) continue ;;
            esac
            if docker compose -f docker-compose.test.yml exec -T $SVC sh -c "$HEALTH_CMD" 2>/dev/null; then
              echo "  $SVC passed"
            else
              echo "  $SVC FAILED"
              FAILED=1
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            echo "::error::One or more services failed their health check"
            exit 1
          fi
          echo "All health checks passed"

      - name: Capture diagnostics on failure
        if: failure()
        run: |
          mkdir -p ci-diagnostics
          echo "=== docker compose ps ===" > ci-diagnostics/compose-status.txt
          docker compose -f docker-compose.test.yml ps --format "table {{.Name}}\t{{.Service}}\t{{.Status}}\t{{.Health}}" \
            >> ci-diagnostics/compose-status.txt 2>&1 || true

          echo "=== sirius-engine inspect ===" > ci-diagnostics/engine-inspect.json
          docker inspect sirius-test-sirius-engine-1 >> ci-diagnostics/engine-inspect.json 2>&1 || true

          for SVC in sirius-engine sirius-api sirius-ui sirius-postgres sirius-rabbitmq sirius-valkey; do
            echo "--- $SVC logs (last 200 lines) ---" > "ci-diagnostics/${SVC}.log"
            docker compose -f docker-compose.test.yml logs --tail=200 "$SVC" \
              >> "ci-diagnostics/${SVC}.log" 2>&1 || true
          done

          echo "::group::Compose Status"
          cat ci-diagnostics/compose-status.txt
          echo "::endgroup::"
          echo "::group::sirius-engine logs"
          cat ci-diagnostics/sirius-engine.log
          echo "::endgroup::"
          echo "::group::sirius-api logs"
          cat ci-diagnostics/sirius-api.log
          echo "::endgroup::"

      - name: Upload diagnostic artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-diagnostics
          path: ci-diagnostics/
          retention-days: 7

      - name: Cleanup test environment
        if: always()
        run: |
          docker compose -f docker-compose.test.yml down --volumes --remove-orphans 2>/dev/null || true

  # ─────────────────────────────────────────────────────────────────────────────
  # Dispatch to sirius-demo when sirius-demo branch is pushed
  # ─────────────────────────────────────────────────────────────────────────────
  dispatch-demo-deployment:
    name: Dispatch Demo Deployment (sirius-demo branch)
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: [detect-changes, build-ui, build-api, build-engine, test]
    if: >
      github.ref == 'refs/heads/sirius-demo' &&
      github.event_name == 'push' &&
      always() &&
      (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped') &&
      (needs.build-ui.result == 'success' || needs.build-ui.result == 'skipped') &&
      (needs.build-api.result == 'success' || needs.build-api.result == 'skipped') &&
      (needs.build-engine.result == 'success' || needs.build-engine.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    steps:
      - name: Dispatch to sirius-demo repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: SiriusScan/sirius-demo
          event-type: sirius-demo-updated
          client-payload: |
            {
              "source_repo": "${{ github.repository }}",
              "source_branch": "${{ github.ref_name }}",
              "source_sha": "${{ github.sha }}",
              "triggered_by": "${{ github.actor }}"
            }

  # ─────────────────────────────────────────────────────────────────────────────
  # Canary dispatch to sirius-demo on every main branch push.
  # Fixed: commit messages with newlines are sanitized before injection into JSON
  # by using `gh api -f` flags which handle escaping correctly.
  # ─────────────────────────────────────────────────────────────────────────────
  dispatch-demo-canary:
    name: Dispatch Demo Canary (main branch)
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: [detect-changes, build-ui, build-api, build-engine, test]
    if: >
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      always() &&
      (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped') &&
      (needs.build-ui.result == 'success' || needs.build-ui.result == 'skipped') &&
      (needs.build-api.result == 'success' || needs.build-api.result == 'skipped') &&
      (needs.build-engine.result == 'success' || needs.build-engine.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    steps:
      - name: Dispatch to sirius-demo repository (canary trigger)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          # Sanitize: take first line only and strip characters that break JSON
          SAFE_MSG=$(printf '%s' "$COMMIT_MSG" | head -1 | tr -d '"\\' | cut -c1-200)

          gh api repos/SiriusScan/sirius-demo/dispatches \
            --method POST \
            -f event_type=sirius-main-updated \
            -f "client_payload[source_repo]=${{ github.repository }}" \
            -f "client_payload[source_branch]=${{ github.ref_name }}" \
            -f "client_payload[source_sha]=${{ github.sha }}" \
            -f "client_payload[triggered_by]=${{ github.actor }}" \
            -f "client_payload[commit_message]=$SAFE_MSG" \
            -f "client_payload[canary]=true"
