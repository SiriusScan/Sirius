name: Sirius CI/CD Pipeline

on:
  push:
    branches: [main, sirius-demo]
  pull_request:
    branches: [main]
  repository_dispatch:
    types: [submodule-update]

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: siriusscan

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    outputs:
      submodule_changes: ${{ steps.changes.outputs.submodule_changes }}
      sirius_ui_changes: ${{ steps.changes.outputs.sirius_ui_changes }}
      sirius_api_changes: ${{ steps.changes.outputs.sirius_api_changes }}
      sirius_engine_changes: ${{ steps.changes.outputs.sirius_engine_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Determine Changed Files
        id: changes
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            # Set changes based on which submodule was updated
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            echo "submodule_changes=true" >> $GITHUB_OUTPUT
            echo "Submodule update detected: $SUBMODULE"
            
            # Extract repository name from full path
            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')
            
            case $REPO_NAME in
              "go-api")
                echo "Affects both sirius-api and sirius-engine"
                echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
              "app-scanner"|"app-terminal"|"sirius-nse"|"app-agent")
                echo "Affects sirius-engine"
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "Unknown submodule, rebuilding everything"
                echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
                echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
                ;;
            esac
          else
            # For direct pushes/PRs, detect actual file changes
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              BASE_SHA=${{ github.event.pull_request.base.sha }}
              HEAD_SHA=${{ github.event.pull_request.head.sha }}
            else
              # For push events
              BASE_SHA=${{ github.event.before }}
              HEAD_SHA=${{ github.event.after }}
            fi
            
            # Check if files in specific directories changed
            git diff --name-only $BASE_SHA $HEAD_SHA > changed_files.txt
            
            if grep -q "sirius-ui/" changed_files.txt; then
              echo "UI changes detected"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
            fi
            
            if grep -q "sirius-api/" changed_files.txt; then
              echo "API changes detected"
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
            fi
            
            if grep -q "sirius-engine/" changed_files.txt || grep -q "rabbitmq/" changed_files.txt; then
              echo "Engine or RabbitMQ changes detected"
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi
            
            # If docker files or CI changed, rebuild everything
            if grep -q -E "(Dockerfile|\.github/|docker-compose)" changed_files.txt; then
              echo "Docker or CI changes detected, rebuilding everything"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi
            
            # If nothing specific changed but we have changes, rebuild everything
            if [ ! -s changed_files.txt ]; then
              echo "General changes detected, rebuilding everything"
              echo "sirius_ui_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_api_changes=true" >> $GITHUB_OUTPUT
              echo "sirius_engine_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  build-ui:
    name: Build & Push UI
    needs: detect-changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.detect-changes.outputs.sirius_ui_changes == 'true'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate metadata
        id: meta
        run: |
          # Set image tags based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

      - name: Install UI dependencies
        run: npm ci
        working-directory: sirius-ui

      - name: Lint UI code
        continue-on-error: true
        run: npm run lint
        working-directory: sirius-ui

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-ui
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-ui
          platforms: ${{ github.event_name == 'pull_request' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-ui:${{ steps.meta.outputs.image_tag }}
            ${{ steps.meta.outputs.also_tag_beta == 'true' && format('{0}/{1}/sirius-ui:beta', env.REGISTRY, env.IMAGE_NAMESPACE) || '' }}

  build-api:
    name: Build & Push API
    needs: detect-changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.detect-changes.outputs.sirius_api_changes == 'true'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate metadata
        id: meta
        run: |
          # Set submodule commit SHAs based on repository_dispatch
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')
            COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
            
            if [ "$REPO_NAME" == "go-api" ]; then
              echo "GO_API_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
              echo "go-api submodule SHA: $COMMIT_SHA"
            fi
          fi

          # Set image tags based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Compile-check API code
        run: |
          go mod download
          go vet ./...
        working-directory: sirius-api

      - name: Run API tests (non-blocking)
        continue-on-error: true
        run: go test ./... -short -count=1
        working-directory: sirius-api

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-api
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-api
          platforms: ${{ github.event_name == 'pull_request' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          push: true
          build-args: |
            GO_API_COMMIT_SHA=${{ env.GO_API_COMMIT_SHA || 'v0.0.15' }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-api:${{ steps.meta.outputs.image_tag }}
            ${{ steps.meta.outputs.also_tag_beta == 'true' && format('{0}/{1}/sirius-api:beta', env.REGISTRY, env.IMAGE_NAMESPACE) || '' }}

  build-engine:
    name: Build & Push Engine
    needs: detect-changes
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: needs.detect-changes.outputs.sirius_engine_changes == 'true'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout Sirius repository
        uses: actions/checkout@v4

      - name: Generate metadata
        id: meta
        run: |
          # Set submodule commit SHAs based on repository_dispatch
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            SUBMODULE="${{ github.event.client_payload.submodule }}"
            REPO_NAME=$(echo $SUBMODULE | awk -F'/' '{print $NF}')
            COMMIT_SHA="${{ github.event.client_payload.commit_sha }}"
            
            # Uppercase for Dockerfile ARGs
            REPO_NAME_UPPER=$(echo $REPO_NAME | tr '-' '_' | tr 'a-z' 'A-Z')
            echo "${REPO_NAME_UPPER}_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
            
            echo "Submodule $REPO_NAME commit SHA: $COMMIT_SHA"
          fi

          # Set image tags based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            TAG="pr-${{ github.event.number }}"
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG="latest"
            echo "also_tag_beta=true" >> $GITHUB_OUTPUT
          else
            TAG="dev"
          fi
          
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Compile-check Engine code
        run: |
          go mod download
          go vet ./...
        working-directory: sirius-engine

      - name: Run Engine tests (non-blocking)
        continue-on-error: true
        run: go test ./... -short -count=1
        working-directory: sirius-engine

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Build and push sirius-engine
        uses: useblacksmith/build-push-action@v2
        with:
          context: ./sirius-engine
          platforms: ${{ github.event_name == 'pull_request' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          push: true
          build-args: |
            GO_API_COMMIT_SHA=${{ env.GO_API_COMMIT_SHA || 'v0.0.14' }}
            APP_SCANNER_COMMIT_SHA=${{ env.APP_SCANNER_COMMIT_SHA || '4a47f73' }}
            APP_TERMINAL_COMMIT_SHA=${{ env.APP_TERMINAL_COMMIT_SHA || 'main' }}
            SIRIUS_NSE_COMMIT_SHA=${{ env.SIRIUS_NSE_COMMIT_SHA || 'main' }}
            APP_AGENT_COMMIT_SHA=${{ env.APP_AGENT_COMMIT_SHA || '50b405a' }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-engine:${{ steps.meta.outputs.image_tag }}
            ${{ steps.meta.outputs.also_tag_beta == 'true' && format('{0}/{1}/sirius-engine:beta', env.REGISTRY, env.IMAGE_NAMESPACE) || '' }}

  test:
    name: Integration Test
    needs: [detect-changes, build-ui, build-api, build-engine]
    runs-on: blacksmith-4vcpu-ubuntu-2404
    if: always() && (needs.build-ui.result == 'success' || needs.build-api.result == 'success' || needs.build-engine.result == 'success')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Blacksmith Builder
        uses: useblacksmith/setup-docker-builder@v1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_PUSH_USER }}
          password: ${{ secrets.GHCR_PUSH_TOKEN }}

      - name: Determine image tag
        id: tag
        run: |
          # Use whichever build job ran successfully
          if [ "${{ needs.build-ui.result }}" == "success" ]; then
            TAG="${{ needs.build-ui.outputs.image_tag }}"
          elif [ "${{ needs.build-api.result }}" == "success" ]; then
            TAG="${{ needs.build-api.outputs.image_tag }}"
          elif [ "${{ needs.build-engine.result }}" == "success" ]; then
            TAG="${{ needs.build-engine.outputs.image_tag }}"
          else
            TAG="latest"
          fi
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $TAG"

      - name: Create test environment
        run: |
          cat > docker-compose.test.yml << 'EOF'
          name: sirius-test
          services:
            sirius-postgres:
              image: postgres:15-alpine
              environment:
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: postgres
                POSTGRES_DB: sirius_test
              tmpfs:
                - /var/lib/postgresql/data
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-rabbitmq:
              image: rabbitmq:3-management
              environment:
                RABBITMQ_DEFAULT_USER: guest
                RABBITMQ_DEFAULT_PASS: guest
              healthcheck:
                test: ["CMD", "rabbitmq-diagnostics", "ping"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-valkey:
              image: valkey/valkey:latest
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 5s
                timeout: 5s
                retries: 10

            sirius-ui:
              image: ${SIRIUS_UI_IMAGE}
              environment:
                - NODE_ENV=production
                - SKIP_ENV_VALIDATION=1
                - DATABASE_URL=postgresql://postgres:postgres@sirius-postgres:5432/sirius_test
                - NEXTAUTH_SECRET=test-secret
                - INITIAL_ADMIN_PASSWORD=test-admin-password
                - NEXTAUTH_URL=http://localhost:3000
                - SIRIUS_API_URL=http://sirius-api:9001
                - NEXT_PUBLIC_SIRIUS_API_URL=http://localhost:9001
                - SIRIUS_API_KEY=ci-placeholder-api-key
              depends_on:
                sirius-postgres:
                  condition: service_healthy
              healthcheck:
                test: ["CMD-SHELL", "wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 15s

            sirius-api:
              image: ${SIRIUS_API_IMAGE}
              environment:
                - GO_ENV=production
                - API_PORT=9001
                - POSTGRES_HOST=sirius-postgres
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres
                - POSTGRES_DB=sirius_test
                - POSTGRES_PORT=5432
                - VALKEY_HOST=sirius-valkey
                - VALKEY_PORT=6379
                - RABBITMQ_URL=amqp://guest:guest@sirius-rabbitmq:5672/
                - LOG_LEVEL=info
                - SIRIUS_API_KEY=ci-placeholder-api-key
              depends_on:
                sirius-postgres:
                  condition: service_healthy
                sirius-rabbitmq:
                  condition: service_healthy
                sirius-valkey:
                  condition: service_healthy
              healthcheck:
                test: ["CMD-SHELL", "wget -q --tries=1 -O /dev/null http://127.0.0.1:9001/health"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 10s

            sirius-engine:
              image: ${SIRIUS_ENGINE_IMAGE}
              environment:
                - GO_ENV=production
                - ENGINE_MAIN_PORT=5174
                - GRPC_AGENT_PORT=50051
                - POSTGRES_HOST=sirius-postgres
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres
                - POSTGRES_DB=sirius_test
                - POSTGRES_PORT=5432
                - VALKEY_HOST=sirius-valkey
                - VALKEY_PORT=6379
                - RABBITMQ_URL=amqp://guest:guest@sirius-rabbitmq:5672/
                - LOG_LEVEL=info
                - SIRIUS_API_KEY=ci-placeholder-api-key
                - SIRIUS_API_URL=http://sirius-api:9001
              depends_on:
                sirius-postgres:
                  condition: service_healthy
                sirius-rabbitmq:
                  condition: service_healthy
                sirius-valkey:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "bash", "-c", "echo > /dev/tcp/127.0.0.1/50051"]
                interval: 10s
                timeout: 5s
                retries: 12
                start_period: 10s
          EOF

          # Inject actual image references (expressions can't live inside the single-quoted heredoc)
          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"
          export SIRIUS_UI_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-ui:${IMAGE_TAG}"
          export SIRIUS_API_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-api:${IMAGE_TAG}"
          export SIRIUS_ENGINE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/sirius-engine:${IMAGE_TAG}"
          echo "SIRIUS_UI_IMAGE=$SIRIUS_UI_IMAGE" >> $GITHUB_ENV
          echo "SIRIUS_API_IMAGE=$SIRIUS_API_IMAGE" >> $GITHUB_ENV
          echo "SIRIUS_ENGINE_IMAGE=$SIRIUS_ENGINE_IMAGE" >> $GITHUB_ENV

      - name: Run integration test
        run: |
          echo "ðŸ§ª Starting integration test..."

          # --- 1. Infrastructure ---
          docker compose -f docker-compose.test.yml up -d sirius-postgres sirius-rabbitmq sirius-valkey

          echo "â³ Waiting for infrastructure services to become healthy..."
          timeout 90 bash -c '
            until docker compose -f docker-compose.test.yml ps --format json | \
              python3 -c "
          import sys, json
          svcs = [json.loads(l) for l in sys.stdin if l.strip()]
          infra = [s for s in svcs if s[\"Service\"] in (\"sirius-postgres\",\"sirius-rabbitmq\",\"sirius-valkey\")]
          healthy = [s for s in infra if s.get(\"Health\",\"\") == \"healthy\"]
          sys.exit(0 if len(healthy) == 3 else 1)
          "; do sleep 3; done
          '
          echo "âœ… Infrastructure healthy"

          # --- 2. Application services ---
          SERVICES_TO_TEST=""
          if [ "${{ needs.detect-changes.outputs.sirius_api_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-api"
          fi
          if [ "${{ needs.detect-changes.outputs.sirius_engine_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-engine"
          fi
          if [ "${{ needs.detect-changes.outputs.sirius_ui_changes }}" == "true" ]; then
            SERVICES_TO_TEST="$SERVICES_TO_TEST sirius-ui"
          fi

          if [ -z "$SERVICES_TO_TEST" ]; then
            echo "â„¹ï¸  No application services to test"
            exit 0
          fi

          echo "ðŸš€ Starting application services:$SERVICES_TO_TEST"
          docker compose -f docker-compose.test.yml up -d $SERVICES_TO_TEST

          # Wait for each service's health endpoint inside its own container.
          # Timeout per service: 180 s. Uses the container's wget, not the host.
          # sirius-api requires X-API-Key header for auth.
          for SVC in $SERVICES_TO_TEST; do
            case $SVC in
              sirius-api)    HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:9001/health" ;;
              sirius-engine) HEALTH_CMD="bash -c 'echo > /dev/tcp/127.0.0.1/50051'" ;;
              sirius-ui)     HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/" ;;
              *) continue ;;
            esac
            echo "â³ Waiting for $SVC..."
            timeout 180 bash -c "
              until docker compose -f docker-compose.test.yml exec -T $SVC sh -c '$HEALTH_CMD' 2>/dev/null; do
                sleep 5
              done
            "
            echo "âœ… $SVC is healthy"
          done

          # --- 3. Final health assertions ---
          echo "ðŸ“Š Service status:"
          docker compose -f docker-compose.test.yml ps

          echo "ðŸ¥ Running final health assertions..."
          FAILED=0
          for SVC in $SERVICES_TO_TEST; do
            case $SVC in
              sirius-api)    HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:9001/health" ;;
              sirius-engine) HEALTH_CMD="bash -c 'echo > /dev/tcp/127.0.0.1/50051'" ;;
              sirius-ui)     HEALTH_CMD="wget -q --tries=1 -O /dev/null http://127.0.0.1:3000/" ;;
              *) continue ;;
            esac
            if docker compose -f docker-compose.test.yml exec -T $SVC sh -c "$HEALTH_CMD" 2>/dev/null; then
              echo "  âœ… $SVC passed"
            else
              echo "  âŒ $SVC FAILED"
              FAILED=1
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            echo "::error::One or more services failed their health check"
            exit 1
          fi
          echo "âœ… All health checks passed"

      - name: Capture diagnostics on failure
        if: failure()
        run: |
          mkdir -p ci-diagnostics
          echo "=== docker compose ps ===" > ci-diagnostics/compose-status.txt
          docker compose -f docker-compose.test.yml ps --format "table {{.Name}}\t{{.Service}}\t{{.Status}}\t{{.Health}}" \
            >> ci-diagnostics/compose-status.txt 2>&1 || true

          echo "=== sirius-engine inspect ===" > ci-diagnostics/engine-inspect.json
          docker inspect sirius-test-sirius-engine-1 >> ci-diagnostics/engine-inspect.json 2>&1 || true

          for SVC in sirius-engine sirius-api sirius-ui sirius-postgres sirius-rabbitmq sirius-valkey; do
            echo "--- $SVC logs (last 200 lines) ---" > "ci-diagnostics/${SVC}.log"
            docker compose -f docker-compose.test.yml logs --tail=200 "$SVC" \
              >> "ci-diagnostics/${SVC}.log" 2>&1 || true
          done

          echo "::group::Compose Status"
          cat ci-diagnostics/compose-status.txt
          echo "::endgroup::"

          echo "::group::sirius-engine logs"
          cat ci-diagnostics/sirius-engine.log
          echo "::endgroup::"

          echo "::group::sirius-api logs"
          cat ci-diagnostics/sirius-api.log
          echo "::endgroup::"

      - name: Upload diagnostic artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-diagnostics
          path: ci-diagnostics/
          retention-days: 7

      - name: Cleanup test environment
        if: always()
        run: |
          docker compose -f docker-compose.test.yml down --volumes --remove-orphans 2>/dev/null || true

  # Dispatch to sirius-demo repository when sirius-demo branch is updated
  dispatch-demo-deployment:
    name: Dispatch Demo Deployment (sirius-demo branch)
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: [detect-changes, build-ui, build-api, build-engine, test]
    if: github.ref == 'refs/heads/sirius-demo' && github.event_name == 'push' && always() && (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped') && (needs.build-ui.result == 'success' || needs.build-ui.result == 'skipped') && (needs.build-api.result == 'success' || needs.build-api.result == 'skipped') && (needs.build-engine.result == 'success' || needs.build-engine.result == 'skipped') && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Dispatch to sirius-demo repository
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: SiriusScan/sirius-demo
          event-type: sirius-demo-updated
          client-payload: |
            {
              "source_repo": "${{ github.repository }}",
              "source_branch": "${{ github.ref_name }}",
              "source_sha": "${{ github.sha }}",
              "triggered_by": "${{ github.actor }}",
              "commit_message": "${{ github.event.head_commit.message }}"
            }

  # Dispatch to sirius-demo repository when main branch is updated
  # This acts as a canary - demo rebuilds on every main branch push to catch bad commits
  dispatch-demo-canary:
    name: Dispatch Demo Canary (main branch)
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: [detect-changes, build-ui, build-api, build-engine, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' && always() && (needs.detect-changes.result == 'success' || needs.detect-changes.result == 'skipped') && (needs.build-ui.result == 'success' || needs.build-ui.result == 'skipped') && (needs.build-api.result == 'success' || needs.build-api.result == 'skipped') && (needs.build-engine.result == 'success' || needs.build-engine.result == 'skipped') && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: Dispatch to sirius-demo repository (canary trigger)
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: SiriusScan/sirius-demo
          event-type: sirius-main-updated
          client-payload: |
            {
              "source_repo": "${{ github.repository }}",
              "source_branch": "${{ github.ref_name }}",
              "source_sha": "${{ github.sha }}",
              "triggered_by": "${{ github.actor }}",
              "commit_message": "${{ github.event.head_commit.message }}",
              "canary": true
            }
