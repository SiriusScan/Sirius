import React, { useState, useMemo, useCallback } from "react";
import dynamic from "next/dynamic";
import { Button } from "~/components/lib/ui/button";
import { Skeleton } from "~/components/lib/ui/skeleton";
import { api } from "~/utils/api";
import { SEVERITY_COLORS } from "~/utils/severityTheme";

const ResponsiveLine = dynamic(
  () => import("@nivo/line").then((m) => m.ResponsiveLine),
  { ssr: false }
);

interface VulnerabilityCounts {
  critical: number;
  high: number;
  medium: number;
  low: number;
  informational: number;
}

interface VulnerabilityTrendChartProps {
  currentCounts: VulnerabilityCounts;
  className?: string;
  height?: number;
}

const VulnerabilityTrendChartComponent: React.FC<
  VulnerabilityTrendChartProps
> = ({ currentCounts, className = "", height = 300 }) => {
  const [viewMode, setViewMode] = useState<"stacked" | "lines">("stacked");

  // Fetch trends data from API
  const { data: trendsData, isLoading: trendsLoading } =
    api.statistics.getVulnerabilityTrends.useQuery(
      { days: 7 },
      {
        refetchOnWindowFocus: false,
        staleTime: 300000, // 5 minutes
      }
    );

  // Generate chart data from API data or fallback to current counts
  const chartData = useMemo(() => {
    const trends = trendsData?.trends ?? [];

    // If we have no trends yet, create a simple dataset with current counts
    if (trends.length === 0) {
      return [
        {
          id: "Critical",
          color: SEVERITY_COLORS.critical.hex,
          data: [{ x: "Now", y: currentCounts.critical }],
        },
        {
          id: "High",
          color: SEVERITY_COLORS.high.hex,
          data: [{ x: "Now", y: currentCounts.high }],
        },
        {
          id: "Medium",
          color: SEVERITY_COLORS.medium.hex,
          data: [{ x: "Now", y: currentCounts.medium }],
        },
        {
          id: "Low",
          color: SEVERITY_COLORS.low.hex,
          data: [{ x: "Now", y: currentCounts.low }],
        },
        {
          id: "Informational",
          color: SEVERITY_COLORS.info.hex,
          data: [{ x: "Now", y: currentCounts.informational }],
        },
      ];
    }

    // Smart timestamp labels from actual snapshot dates
    const first = new Date(trends[0]!.timestamp);
    const last = new Date(trends[trends.length - 1]!.timestamp);
    const allSameDay =
      first.getFullYear() === last.getFullYear() &&
      first.getMonth() === last.getMonth() &&
      first.getDate() === last.getDate();

    const timeLabels = trends.map((trend) => {
      const d = new Date(trend.timestamp);
      if (allSameDay) {
        // All snapshots from the same day — show time only
        return d.toLocaleTimeString("en-US", {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        });
      }
      // Spanning multiple days — compact date + time
      return d.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      });
    });

    return [
      {
        id: "Critical",
        color: SEVERITY_COLORS.critical.hex,
        data: trends.map((trend, i) => ({
          x: timeLabels[i],
          y: trend.counts.critical,
        })),
      },
      {
        id: "High",
        color: SEVERITY_COLORS.high.hex,
        data: trends.map((trend, i) => ({
          x: timeLabels[i],
          y: trend.counts.high,
        })),
      },
      {
        id: "Medium",
        color: SEVERITY_COLORS.medium.hex,
        data: trends.map((trend, i) => ({
          x: timeLabels[i],
          y: trend.counts.medium,
        })),
      },
      {
        id: "Low",
        color: SEVERITY_COLORS.low.hex,
        data: trends.map((trend, i) => ({
          x: timeLabels[i],
          y: trend.counts.low,
        })),
      },
      {
        id: "Informational",
        color: SEVERITY_COLORS.info.hex,
        data: trends.map((trend, i) => ({
          x: timeLabels[i],
          y: trend.counts.informational,
        })),
      },
    ];
  }, [trendsData, currentCounts]);

  const theme = useMemo(
    () => ({
      text: {
        fontSize: 11,
        fill: "#9ca3af",
      },
      axis: {
        domain: {
          line: {
            stroke: "#374151",
            strokeWidth: 1,
          },
        },
        legend: {
          text: {
            fontSize: 12,
            fill: "#9ca3af",
          },
        },
        ticks: {
          line: {
            stroke: "#374151",
            strokeWidth: 1,
          },
          text: {
            fontSize: 10,
            fill: "#6b7280",
          },
        },
      },
      grid: {
        line: {
          stroke: "#1f2937",
          strokeWidth: 1,
        },
      },
      legends: {
        text: {
          fontSize: 11,
          fill: "#9ca3af",
        },
      },
      tooltip: {
        container: {
          background: "#111827",
          color: "#f9fafb",
          fontSize: 12,
          borderRadius: "6px",
          boxShadow: "0 8px 24px rgba(0,0,0,0.5)",
          border: "1px solid rgba(139, 92, 246, 0.25)",
        },
      },
    }),
    [],
  );

  const getSerieColor = useCallback((d: { color: string }) => d.color, []);

  // Stable object references to prevent Nivo from re-animating
  const margin = useMemo(() => ({ top: 10, right: 110, bottom: 50, left: 50 }), []);
  const xScale = useMemo(() => ({ type: "point" as const }), []);
  const yScale = useMemo(
    () => ({
      type: "linear" as const,
      min: 0 as const,
      max: "auto" as const,
      stacked: viewMode === "stacked",
      reverse: false,
    }),
    [viewMode],
  );
  const axisBottom = useMemo(
    () => ({
      tickSize: 5,
      tickPadding: 5,
      tickRotation: -30,
      legendOffset: 36,
      legendPosition: "middle" as const,
    }),
    [],
  );
  const axisLeft = useMemo(
    () => ({
      tickSize: 5,
      tickPadding: 5,
      tickRotation: 0,
      legend: "Vulnerabilities",
      legendOffset: -40,
      legendPosition: "middle" as const,
    }),
    [],
  );
  const pointBorderColor = useMemo(() => ({ from: "serieColor" as const }), []);
  const legends = useMemo(
    () => [
      {
        anchor: "bottom-right" as const,
        direction: "column" as const,
        justify: false,
        translateX: 100,
        translateY: 0,
        itemsSpacing: 4,
        itemDirection: "left-to-right" as const,
        itemWidth: 80,
        itemHeight: 16,
        itemOpacity: 0.85,
        symbolSize: 10,
        symbolShape: "circle" as const,
        effects: [
          {
            on: "hover" as const,
            style: {
              itemOpacity: 1,
            },
          },
        ],
      },
    ],
    [],
  );

  return (
    <div className={`flex flex-col ${className}`}>
      {/* Controls */}
      <div className="mb-3 flex items-center justify-between">
        <div className="flex gap-2">
          <Button
            size="sm"
            variant={viewMode === "stacked" ? "default" : "outline"}
            onClick={() => setViewMode("stacked")}
            className="h-7 px-3 text-xs"
          >
            Stacked
          </Button>
          <Button
            size="sm"
            variant={viewMode === "lines" ? "default" : "outline"}
            onClick={() => setViewMode("lines")}
            className="h-7 px-3 text-xs"
          >
            By Severity
          </Button>
        </div>
        <span className="text-xs text-muted-foreground">
          {trendsLoading
            ? "Loading trends..."
            : trendsData?.trends && trendsData.trends.length > 0
            ? `${trendsData.trends.length} snapshot${trendsData.trends.length === 1 ? "" : "s"}`
            : "Current snapshot"}
        </span>
      </div>

      {/* Chart */}
      <div style={{ height: `${height}px` }}>
        <ResponsiveLine
          data={chartData}
          theme={theme}
          colors={getSerieColor}
          margin={margin}
          xScale={xScale}
          yScale={yScale}
          curve="monotoneX"
          axisTop={null}
          axisRight={null}
          axisBottom={axisBottom}
          axisLeft={axisLeft}
          enableGridX={false}
          enableGridY={true}
          lineWidth={viewMode === "lines" ? 2 : 0}
          enableArea={viewMode === "stacked"}
          areaOpacity={viewMode === "stacked" ? 0.7 : 0}
          pointSize={6}
          pointColor="#ffffff"
          pointBorderWidth={2}
          pointBorderColor={pointBorderColor}
          enablePointLabel={false}
          useMesh={true}
          enableSlices="x"
          legends={legends}
        />
      </div>
    </div>
  );
};

// Memoized export to prevent unnecessary re-renders
export const VulnerabilityTrendChart = React.memo(
  VulnerabilityTrendChartComponent
);

// Loading skeleton
export const VulnerabilityTrendChartSkeleton: React.FC<{ height?: number }> = ({
  height = 300,
}) => {
  return (
    <div className="flex flex-col space-y-3">
      <div className="flex justify-between">
        <div className="flex gap-2">
          <Skeleton className="h-7 w-20" />
          <Skeleton className="h-7 w-24" />
        </div>
        <Skeleton className="h-4 w-32" />
      </div>
      <Skeleton className="w-full" style={{ height: `${height}px` }} />
    </div>
  );
};
