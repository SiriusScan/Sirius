[
  {
    "id": "0",
    "title": "PHASE 0: Project Foundation",
    "description": "Set up project structure and create the basic system monitor page with mock data",
    "details": "Create the system monitor page, add navigation link, and implement basic UI structure with mock data for health status and logs. This establishes the foundation for the monitoring dashboard.",
    "status": "done",
    "priority": "high",
    "dependencies": [],
    "subtasks": [
      {
        "id": "0.1",
        "title": "Create System Monitor Page",
        "description": "Create new Next.js page for system monitoring with basic layout and navigation",
        "details": "Create /pages/system-monitor.tsx with Layout component, add navigation link in Header.tsx Settings dropdown, implement basic page structure with placeholder content for health status and logs sections",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "testStrategy": "Navigate to /system-monitor page, verify Settings dropdown contains System Monitor link, confirm page loads without errors"
      },
      {
        "id": "0.2",
        "title": "Create Service Status Cards Component",
        "description": "Build reusable component for displaying individual service health status",
        "details": "Create ServiceStatusCard component with props for service name, status (up/down), last checked time, and optional details. Use existing design patterns from other components. Include loading states and error indicators.",
        "status": "done",
        "priority": "high",
        "dependencies": ["0.1"],
        "testStrategy": "Render ServiceStatusCard with various states (up, down, loading, error) and verify visual appearance matches design system"
      },
      {
        "id": "0.3",
        "title": "Create Log Viewer Component",
        "description": "Build log viewer component using TanStack Table with mock data",
        "details": "Create LogViewer component using TanStack Table, implement columns for timestamp, service, level, message. Add basic filtering by log level and search functionality. Use mock log data initially.",
        "status": "done",
        "priority": "high",
        "dependencies": ["0.1"],
        "testStrategy": "Render LogViewer with mock data, verify table displays correctly, test filtering and search functionality"
      },
      {
        "id": "0.4",
        "title": "Implement Mock Data and State Management",
        "description": "Create mock data structures and basic state management for the monitoring dashboard",
        "details": "Define TypeScript interfaces for service status and log entries. Create mock data generators for both. Implement basic state management with useState hooks for real-time updates simulation.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["0.2", "0.3"],
        "testStrategy": "Verify mock data displays correctly in both components, test state updates and re-rendering"
      }
    ]
  },
  {
    "id": "1",
    "title": "PHASE 1: Service Health Monitoring",
    "description": "Implement real health check APIs and connect frontend to backend for service status monitoring",
    "details": "Create comprehensive health check system that monitors all microservices using patterns from container testing. Implement APIs for health checks and connect frontend to display real service status.",
    "status": "done",
    "priority": "high",
    "dependencies": ["0"],
    "subtasks": [
      {
        "id": "1.1",
        "title": "Extend API Health Check Endpoint",
        "description": "Enhance existing /health endpoint to include comprehensive system health information",
        "details": "Modify sirius-api health handler to check database connectivity, Valkey connectivity, and other dependencies. Return detailed health status including individual service checks and overall system status.",
        "status": "done",
        "priority": "high",
        "dependencies": ["0.4"],
        "testStrategy": "Call /health endpoint and verify response includes database, cache, and other service health information"
      },
      {
        "id": "1.2",
        "title": "Create System Health Check API",
        "description": "Create new API endpoint for comprehensive system health monitoring",
        "details": "Create /api/v1/system/health endpoint that checks all services: UI (self-check), API (self-check), Engine (port 5174), PostgreSQL (connection), Valkey (ping), RabbitMQ (status). Return structured response with individual service statuses.",
        "status": "done",
        "priority": "high",
        "dependencies": ["1.1"],
        "testStrategy": "Call system health endpoint and verify all service checks work correctly, test with services up and down"
      },
      {
        "id": "1.3",
        "title": "Implement Health Check Service in Frontend",
        "description": "Create service for making health check API calls and managing health status state",
        "details": "Create healthCheckService.ts with functions to call system health API, implement polling mechanism with configurable intervals, add error handling and retry logic, manage loading and error states.",
        "status": "done",
        "priority": "high",
        "dependencies": ["1.2"],
        "testStrategy": "Test health check service with various scenarios: successful checks, API errors, network timeouts, verify polling works correctly"
      },
      {
        "id": "1.4",
        "title": "Connect Frontend to Health Check APIs",
        "description": "Replace mock data with real health check data in the system monitor page",
        "details": "Update system monitor page to use health check service instead of mock data, implement real-time updates with polling, add error handling for failed health checks, display appropriate loading and error states.",
        "status": "done",
        "priority": "high",
        "dependencies": ["1.3"],
        "testStrategy": "Verify system monitor shows real service status, test with services running and stopped, confirm real-time updates work"
      }
    ]
  },
  {
    "id": "2",
    "title": "PHASE 2: Centralized Logging Infrastructure",
    "description": "Implement centralized logging system with Valkey storage and log management APIs",
    "details": "Create comprehensive logging infrastructure that allows all services to submit logs to a centralized store. Implement log storage, retrieval, and management APIs with retention policies.",
    "status": "done",
    "priority": "high",
    "dependencies": ["1"],
    "subtasks": [
      {
        "id": "2.1",
        "title": "Design Log Format and Metadata Structure",
        "description": "Define standardized log format and metadata structure for all services",
        "details": "Create TypeScript interfaces for log entries including: timestamp, service, level (info, warn, error, debug), message, metadata (request_id, user_id, etc.), source (component/function). Document log format standards for all services.",
        "status": "done",
        "priority": "high",
        "dependencies": ["1.4"],
        "testStrategy": "Verify log format interfaces are properly defined and documented, test serialization/deserialization"
      },
      {
        "id": "2.2",
        "title": "Implement Log Storage API",
        "description": "Create API endpoints for log submission and retrieval using Valkey storage",
        "details": "Create /api/v1/logs/submit endpoint for log submission, /api/v1/logs/retrieve endpoint for log retrieval with pagination and filtering. Implement Valkey-based storage with proper key structure and data serialization. Add log retention policy (max 1000 logs, oldest first out).",
        "status": "done",
        "priority": "high",
        "dependencies": ["2.1"],
        "testStrategy": "Test log submission and retrieval APIs, verify data persistence in Valkey, test retention policy with large number of logs"
      },
      {
        "id": "2.3",
        "title": "Create Log Management Service",
        "description": "Implement service for log operations including submission, retrieval, and cleanup",
        "details": "Create logService.ts with functions for submitting logs, retrieving logs with filtering, implementing retention policy, managing log storage keys, handling errors and edge cases.",
        "status": "done",
        "priority": "high",
        "dependencies": ["2.2"],
        "testStrategy": "Test log service with various scenarios: normal operations, high volume, error conditions, verify retention policy works correctly"
      },
      {
        "id": "2.4",
        "title": "Integrate Logging into Existing Services",
        "description": "Add logging calls to existing services (API, Engine) for system events",
        "details": "Add logging calls to sirius-api for request/response events, errors, and important operations. Add logging to sirius-engine for scan events, agent communications, and system events. Ensure all logs follow the standardized format.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["2.3"],
        "testStrategy": "Verify logs are being generated by services, check log format consistency, test log submission from multiple services"
      }
    ]
  },
  {
    "id": "3",
    "title": "PHASE 3: Log Viewer and Dashboard Integration",
    "description": "Connect log viewer to real logging system and complete dashboard functionality",
    "details": "Replace mock log data with real logging system, implement advanced filtering and search, add real-time log updates, and complete the monitoring dashboard functionality.",
    "status": "done",
    "priority": "high",
    "dependencies": ["2"],
    "subtasks": [
      {
        "id": "3.1",
        "title": "Connect Log Viewer to Real Logging System",
        "description": "Replace mock data in LogViewer with real log data from logging APIs",
        "details": "Update LogViewer component to use log service instead of mock data, implement real-time log updates with polling, add error handling for log retrieval failures, implement proper loading states.",
        "status": "done",
        "priority": "high",
        "dependencies": ["2.4"],
        "testStrategy": "Verify log viewer displays real logs from the system, test real-time updates, confirm error handling works"
      },
      {
        "id": "3.2",
        "title": "Implement Advanced Log Filtering and Search",
        "description": "Add comprehensive filtering and search capabilities to the log viewer",
        "details": "Implement filtering by log level, service, time range, and search by message content. Add UI controls for filters, implement debounced search, add clear filters functionality, optimize queries for performance.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["3.1"],
        "testStrategy": "Test all filtering options, verify search functionality, test performance with large log volumes"
      },
      {
        "id": "3.3",
        "title": "Add Real-time Updates and Performance Optimization",
        "description": "Implement real-time log updates and optimize dashboard performance",
        "details": "Add real-time log updates with efficient polling, implement log pagination for large datasets, add performance optimizations (memoization, virtual scrolling if needed), implement proper cleanup for polling intervals.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["3.2"],
        "testStrategy": "Test real-time updates, verify performance with large datasets, check for memory leaks and proper cleanup"
      },
      {
        "id": "3.4",
        "title": "Complete Dashboard Layout and Polish",
        "description": "Finalize dashboard layout, add additional monitoring features, and polish the UI",
        "details": "Organize dashboard layout with proper spacing and sections, add system overview metrics (total logs, error count, uptime), implement responsive design, add loading skeletons, improve error states and user feedback.",
        "status": "done",
        "priority": "low",
        "dependencies": ["3.3"],
        "testStrategy": "Test dashboard on different screen sizes, verify all UI elements work correctly, check accessibility and user experience"
      }
    ]
  },
  {
    "id": "4",
    "title": "PHASE 4: Testing and Documentation",
    "description": "Complete testing, documentation, and final cleanup for the system monitoring feature",
    "details": "Implement comprehensive testing for all components, create documentation for the monitoring system, and perform final cleanup and optimization.",
    "status": "done",
    "priority": "medium",
    "dependencies": ["3"],
    "subtasks": [
      {
        "id": "4.1",
        "title": "Implement Component Testing",
        "description": "Create unit tests for all monitoring components and services",
        "details": "Write unit tests for ServiceStatusCard, LogViewer, healthCheckService, logService components. Test error handling, edge cases, and integration scenarios. Ensure good test coverage for critical functionality.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["3.4"],
        "testStrategy": "Run test suite and verify all tests pass, check test coverage meets requirements"
      },
      {
        "id": "4.2",
        "title": "Create System Monitoring Documentation",
        "description": "Document the system monitoring feature for developers and users",
        "details": "Create documentation for system monitoring dashboard usage, API endpoints for health checks and logging, log format standards, troubleshooting guide, and configuration options.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["4.1"],
        "testStrategy": "Review documentation for completeness and accuracy, test troubleshooting scenarios"
      },
      {
        "id": "4.3",
        "title": "Performance Testing and Optimization",
        "description": "Test system performance under load and optimize as needed",
        "details": "Test dashboard performance with high log volumes, test health check performance with many concurrent requests, optimize database queries and API responses, implement caching where appropriate.",
        "status": "done",
        "priority": "low",
        "dependencies": ["4.2"],
        "testStrategy": "Run performance tests, verify system handles expected load, check for bottlenecks and optimize"
      },
      {
        "id": "4.4",
        "title": "Clean Up Project Files",
        "description": "Remove temporary files and update documentation as needed",
        "details": "Delete any temporary files created during development, update README if needed, ensure all documentation is current, merge feature branch back to main, clean up project files",
        "status": "done",
        "priority": "medium",
        "dependencies": ["4.3"],
        "testStrategy": "Verify no temporary files remain and documentation is up to date"
      }
    ]
  },
  {
    "id": "5",
    "title": "PHASE 5: Real System Resource Monitoring",
    "description": "Implement Valkey-based system resource monitoring with real container metrics",
    "details": "Replace mock system resource data with real metrics collected from each container. Each service reports its own system metrics to Valkey, and the API aggregates this data for the monitoring dashboard.",
    "status": "done",
    "priority": "high",
    "dependencies": ["4"],
    "subtasks": [
      {
        "id": "5.1",
        "title": "Create System Monitor Binary",
        "description": "Create lightweight Go binary for collecting and reporting system metrics",
        "details": "Create a standalone Go program that collects CPU, memory, disk, and network metrics from the current container. Report metrics to Valkey at regular intervals (every 30 seconds). Use existing Go API libraries for Valkey connectivity.",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "testStrategy": "Test system monitor binary in isolation, verify it collects accurate metrics and reports to Valkey successfully"
      },
      {
        "id": "5.2",
        "title": "Integrate System Monitor into Container Builds",
        "description": "Add system monitor binary to all container Dockerfiles",
        "details": "Update Dockerfiles for sirius-api, sirius-ui, sirius-engine, sirius-postgres, sirius-valkey, and sirius-rabbitmq to include the system monitor binary. Configure each container to run the system monitor as a background process.",
        "status": "done",
        "priority": "high",
        "dependencies": ["5.1"],
        "testStrategy": "Build all containers and verify system monitor is running in each, check that metrics are being reported to Valkey"
      },
      {
        "id": "5.3",
        "title": "Update API to Read Real Metrics from Valkey",
        "description": "Modify system resource API endpoints to read real metrics from Valkey",
        "details": "Update /api/v1/system/resources endpoint to read aggregated metrics from Valkey instead of generating mock data. Implement proper error handling for missing or stale metrics data.",
        "status": "done",
        "priority": "high",
        "dependencies": ["5.2"],
        "testStrategy": "Test API endpoints return real metrics data, verify error handling for missing containers or stale data"
      },
      {
        "id": "5.4",
        "title": "Implement Real Docker Logs Collection",
        "description": "Replace mock Docker logs with real log collection from containers",
        "details": "Update system monitor to also collect and report container logs to Valkey. Modify /api/v1/system/logs endpoint to read real logs from Valkey instead of generating mock data.",
        "status": "done",
        "priority": "high",
        "dependencies": ["5.3"],
        "testStrategy": "Verify real container logs are being collected and displayed in the monitoring dashboard"
      },
      {
        "id": "5.5",
        "title": "Add Metrics Retention and Cleanup",
        "description": "Implement data retention policies for system metrics and logs",
        "details": "Add cleanup mechanisms to prevent Valkey from growing indefinitely. Implement retention policies for metrics (keep 24 hours) and logs (keep 7 days). Add background cleanup processes.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["5.4"],
        "testStrategy": "Test retention policies work correctly, verify Valkey doesn't grow beyond expected limits"
      },
      {
        "id": "5.6",
        "title": "Update Frontend to Handle Real Data",
        "description": "Ensure frontend components work correctly with real metrics data",
        "details": "Test and update frontend components to handle real metrics data format, add proper error handling for missing or malformed data, ensure UI updates correctly with real-time data.",
        "status": "done",
        "priority": "medium",
        "dependencies": ["5.4"],
        "testStrategy": "Test frontend with real data, verify all components display correctly and handle edge cases"
      }
    ]
  }
]
